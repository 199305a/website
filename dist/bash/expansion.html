<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bash 的模式扩展 - Bash 脚本教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="Bash 的模式扩展"><link rel="apple-touch-icon" sizes="57x57" href="assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com</a></div><div class="navbar-menu"><div class="navbar-end"><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/bash-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8"><nav class="breadcrumb is-size-5-desktop" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;Bash 脚本教程</a></li><li class="is-active"><a class="has-text-grey" href="expansion.html">Bash 的模式扩展</a></li></ul></nav><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="string.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 字符串操作</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="arithmetic.html">Bash 的算术运算 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content is-size-5-desktop"><h1 class="title">Bash 的模式扩展</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p><p>这种特殊字符的扩展，称为通配符扩展（wildcard expansion）或者模式扩展（globbing）。Bash 一共提供八种扩展，先进行扩展，然后再执行命令。</p><p>早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字保留了下来。特殊字符的扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p><p>Bash 允许用户关闭通配符扩展。</p><pre class="hljs"><code>$ <span class="hljs-built_in">set</span> -o <span class="hljs-built_in">noglob</span>
<span class="hljs-comment"># 或者</span>
$ <span class="hljs-built_in">set</span> -f
</code></pre><p>下面的命令可以重新打开通配符扩展。</p><pre class="hljs"><code>$ <span class="hljs-built_in">set</span> +o <span class="hljs-built_in">noglob</span>
<span class="hljs-comment"># 或者</span>
$ <span class="hljs-built_in">set</span> +f
</code></pre><h2 id="波浪线扩展">波浪线扩展 <a class="markdownIt-Anchor" href="#波浪线扩展">#</a></h2><p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> ~
/home/me
</code></pre><p>如果要进入主目录的某个子目录，通常会把子目录放在波浪号后面。</p><pre class="hljs"><code><span class="hljs-comment"># 进入 /home/me/foo 目录</span>
$ <span class="hljs-built_in">cd</span> ~/foo
</code></pre><p>如果<code>~</code>后面是已经存在的用户名，则会返回该用户的主目录。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> ~foo
/home/foo

$ <span class="hljs-built_in">echo</span> ~root
/root
</code></pre><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p><p>如果是不存在的用户名，则波浪号扩展不起作用。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> ~nonExistedUser
~nonExistedUser
</code></pre><p>此外，<code>~+</code>会返回当前所在的目录，等同于<code>pwd</code>命令。</p><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> ~/foo
$ <span class="hljs-built_in">echo</span> ~+
/home/me/foo
</code></pre><h2 id="-字符扩展"><code>?</code> 字符扩展 <a class="markdownIt-Anchor" href="#-字符扩展">#</a></h2><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>开头后面跟着三个字符的文件名。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt 和 b.txt</span>
$ ls ?.txt
a.txt b.txt
</code></pre><p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p><p>如果匹配多个字符，就需要多个<code>?</code>连用。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls ??.txt
ab.txt
</code></pre><p>上面命令中，<code>??</code>匹配了两个字符。</p><p>注意，Bash 是先进行扩展，再执行命令。因此，扩展的结果决定了命令执行的结果，各种扩展只是 Bash 的功能，命令本身并不存在参数扩展，收到什么参数就原样执行。</p><pre class="hljs"><code><span class="hljs-comment"># 当前目录有 a.txt 文件</span>
$ <span class="hljs-built_in">echo</span> ?.txt
a.txt

<span class="hljs-comment"># 当前目录为空目录</span>
$ <span class="hljs-built_in">echo</span> ?.txt
?.txt
</code></pre><p>上面例子中，如果<code>?.txt</code>可以扩展成文件名，<code>echo</code>命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code>就会原样输出<code>?.txt</code>。</p><h2 id="-字符扩展-1"><code>*</code> 字符扩展 <a class="markdownIt-Anchor" href="#-字符扩展-1">#</a></h2><p><code>*</code>字符代表文件路径里面的任意数量字符，包括零个字符。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls *.txt
a.txt b.txt ab.txt

<span class="hljs-comment"># 输出所有文件</span>
$ ls *
</code></pre><p>下面是<code>*</code>匹配空字符的例子。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls a*.txt
a.txt ab.txt

$ ls *b*
b.txt ab.txt
</code></pre><p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件）。</p><pre class="hljs"><code><span class="hljs-comment"># 显示所有隐藏文件</span>
$ <span class="hljs-built_in">echo</span> .*

<span class="hljs-comment"># 只显示正常的隐藏文件，不显示 . 和 .. 这两个特殊文件</span>
$ <span class="hljs-built_in">echo</span> .[!.]*
</code></pre><h2 id="方括号模式">方括号模式 <a class="markdownIt-Anchor" href="#方括号模式">#</a></h2><p>方括号模式是<code>[...]</code>，可以匹配方括号之中的任意一个字符，比如<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。该模式属于文件名匹配，即匹配后的结果必须符合现有的文件路径，如果不存在匹配，就会保持原样，不进行扩展。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt 和 b.txt</span>
$ ls [ab].txt
a.txt b.txt

<span class="hljs-comment"># 只存在文件 a.txt</span>
$ ls [ab].txt
a.txt

<span class="hljs-comment"># 不存在文件 a.txt 和 b.txt</span>
$ ls [ab].txt
ls: 无法访问<span class="hljs-string">'[ab].txt'</span>: 没有那个文件或目录
</code></pre><p>上面命令中，<code>[ab]</code>表示可以扩展成<code>a</code>或<code>b</code>。具体的执行结果，取决于当前目录是否包含指定的文件。</p><p>方括号模式还有两种变体：<code>[^...]</code>和<code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code>或<code>[!abc]</code>表示匹配除了<code>a</code>、<code>b</code>、<code>c</code>以外的字符。</p><pre class="hljs"><code>$ ls ?[!a]?
aba bbb
</code></pre><p>上面命令中，<code>[!a]</code>表示文件名第二个字符不是<code>a</code>的文件名。</p><p>注意，如果需要匹配<code>[</code>字符，可以放在方括号内，比如<code>[[aeiou]</code>。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>或<code>[aeiou-]</code>。</p><h2 id="start-end-模式">[start-end] 模式 <a class="markdownIt-Anchor" href="#start-end-模式">#</a></h2><p>方括号模式<code>[start-end]</code>可以表示一个连续的范围。</p><pre class="hljs"><code><span class="hljs-comment"># 存在文件 a.txt、b.txt 和 c.txt</span>
$ ls [a-c].txt
a.txt
b.txt
c.txt

<span class="hljs-comment"># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ ls report[0-9].txt
report1.txt
report2.txt
report3.txt
...
</code></pre><p>下面是更多的例子。</p><ul><li><code>[a-z]</code>：所有小写字母。</li><li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li><li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li><li><code>[abc]*</code>：所有以<code>a</code>、<code>b</code>、<code>c</code>字符之一开头的文件名。</li><li><code>program.[co]</code>：文件<code>program.c</code>与文件<code>program.o</code>。</li><li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以<code>BACKUP.</code>开头，后面是三个数字的文件名。</li></ul><p>方括号模式的否定形式，也可以使用连续范围的写法<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code>表示匹配非英文字母的字符。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> report[!1–3].txt
report4.txt report5.txt
</code></pre><p>上面代码中，<code>[!1-3]</code>表示排除1、2和3。</p><h2 id="大括号扩展">大括号扩展 <a class="markdownIt-Anchor" href="#大括号扩展">#</a></h2><p>大括号扩展<code>{...}</code>表示分别输出大括号里面的所有值，各个值之间使用逗号分隔。这种扩展跟上面的扩展都不一样，不是文件名扩展，即不会扩展成文件名，而是扩展成所有给定的值。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {1,2,3}
1 2 3

$ <span class="hljs-built_in">echo</span> d{a,e,i,u,o}g
dag deg dig dug dog

$ <span class="hljs-built_in">echo</span> Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre><p>注意，大括号内部的逗号前后不能有空格。否则，大括号模式会失效。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {1 , 2}
{1 , 2}
</code></pre><p>如果逗号前面没有值，就表示扩展的第一项为空。</p><pre class="hljs"><code>$ cp a.log{,.bak}
<span class="hljs-comment"># 等同于</span>
<span class="hljs-comment"># cp a.log a.log.bak</span>
</code></pre><p>大括号可以嵌套。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {j{p,pe}g,png}
jpg jpeg png

$ <span class="hljs-built_in">echo</span> a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
</code></pre><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {cat,d*}
cat dawg dg dig dog doug dug
</code></pre><p>上面代码中，会先进行大括号扩展，然后进行<code>*</code>扩展。</p><p>大括号可以用于多字符的模式，方括号不行。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {cat,dog}
cat dog
</code></pre><p>大括号模式<code>{...}</code>与方括号模式<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开，因为大括号不是文件名扩展。</p><pre class="hljs"><code><span class="hljs-comment"># 不存在 a.txt 和 b.txt</span>
$ <span class="hljs-built_in">echo</span> [ab].txt
[ab].txt

$ <span class="hljs-built_in">echo</span> {a,b}.txt
a.txt b.txt
</code></pre><p>上面代码中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>{a,b}.txt</code>可以照样展开。</p><h2 id="startend-扩展">{start..end} 扩展 <a class="markdownIt-Anchor" href="#startend-扩展">#</a></h2><p>大括号里面两个点的<code>{start..end}</code>模式，表示扩展成一个连续序列，然后分别输出。比如<code>{a..z}</code>可以扩展成26个小写英文字母，然后输出。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {a..c}
a b c

$ <span class="hljs-built_in">echo</span> {c..a}
c b a

$ <span class="hljs-built_in">echo</span> d{a..d}g
dag dbg dcg ddg

$ <span class="hljs-built_in">echo</span> {1..4}
1 2 3 4

$ <span class="hljs-built_in">echo</span> Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre><p>大括号的双点号支持逆序。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {5..1}
5 4 3 2 1

$ <span class="hljs-built_in">echo</span> {E..A}
E D C B A
</code></pre><p>如果遇到无法解释的扩展，模式会原样输出。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {a1..3c}
{a1..3c}
</code></pre><p>这种模式与逗号联用，可以写出复杂的模式。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> .{mp{3..4},m4{a,b,p,v}}
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre><p>大括号扩展的常见用途为新建一系列目录。</p><pre class="hljs"><code>$ mkdir {2007..2009}-{01..12}
</code></pre><p>上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。</p><p>整数前面可以使用前导<code>0</code>，然后输出的每一项都有前导<code>0</code>。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {01..5}
01 02 03 04 05

$ <span class="hljs-built_in">echo</span> {001..5}
001 002 003 004 005
</code></pre><p>大括号里面还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {0..8..2}
0 2 4 6 8
</code></pre><p>上面代码将<code>0</code>扩展到<code>8</code>，每次递增的长度为<code>2</code>，所以一共输出5个数字。</p><p>多个大括号连用，会有循环处理的效果。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> {a..c}{1..3}
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre><p>这个写法可以直接用于<code>for</code>循环。</p><pre class="hljs"><code><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..4}
<span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
</code></pre><h2 id="变量扩展">变量扩展 <a class="markdownIt-Anchor" href="#变量扩展">#</a></h2><p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>
/bin/bash
</code></pre><p>变量名除了放在美元符号后面，也可以放在<code>${}</code>里面。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">${SHELL}</span>
/bin/bash
</code></pre><p><code>${!...*}</code>或<code>${!...@}</code>可以返回所有匹配的变量名。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">${!S*}</span>
SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK
</code></pre><p>上面例子中，<code>${!S*}</code>扩展成所有以<code>S</code>开头的变量名。</p><h2 id="子命令扩展">子命令扩展 <a class="markdownIt-Anchor" href="#子命令扩展">#</a></h2><p><code>$(...)</code>可以扩展成另一个命令的运行结果，内部命令的所有输出都会作为返回值。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> $(date)
Tue Jan 28 00:01:13 CST 2020
</code></pre><p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p><p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> `date`
Tue Jan 28 00:01:13 CST 2020
</code></pre><p><code>$(...)</code>还可以嵌套，比如<code>$(ls $(pwd))</code>。</p><h2 id="算术扩展">算术扩展 <a class="markdownIt-Anchor" href="#算术扩展">#</a></h2><p><code>$((...))</code>可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> $((2 + 2))
4
</code></pre><h2 id="字符类">字符类 <a class="markdownIt-Anchor" href="#字符类">#</a></h2><p><code>[[:class:]]</code>表示一个字符类，匹配某一类特定字符之中的一个。常用的字符类如下。</p><ul><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键。</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li></ul><p>请看下面的例子。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> [[:upper:]]*
</code></pre><p>上面命令输出所有大写字母开头的文件名。</p><p>字符类的第一个方括号后面，可以加上感叹号<code>!</code>，表示否定。比如，<code>[![:digit:]]</code>匹配所有非数字。</p><pre class="hljs"><code>$ <span class="hljs-built_in">echo</span> [![:digit:]]*
</code></pre><p>上面命令输出所有不以数字开头的文件名。</p><h2 id="使用注意点">使用注意点 <a class="markdownIt-Anchor" href="#使用注意点">#</a></h2><p>通配符有一些使用注意点，不可不知。</p><p><strong>（1）通配符是先解释，再执行。</strong></p><p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p><pre class="hljs"><code>$ ls a*.txt
ab.txt
</code></pre><p>上面命令的执行过程是，Bash 先将<code>a*.txt</code>扩展成<code>ab.txt</code>，然后再执行<code>ls ab.txt</code>。</p><p><strong>（2）通配符不匹配，会原样输出。</strong></p><p>Bash 扩展通配符的时候，发现不存在匹配的文件，会将通配符原样输出。</p><pre class="hljs"><code><span class="hljs-comment"># 不存在 r 开头的文件名</span>
$ <span class="hljs-built_in">echo</span> r*
r*
</code></pre><p>上面代码中，由于不存在<code>r</code>开头的文件名，<code>r*</code>会原样输出。</p><p>下面是另一个例子。</p><pre class="hljs"><code>$ ls *.csv
ls: *.csv: No such file or directory
</code></pre><p>另外，前面已经说过，这条规则对大括号模式<code>{...}</code>不适用。</p><p><strong>（3）只适用于单层路径。</strong></p><p>上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符（<code>/</code>）。</p><p>如果要匹配子目录里面的文件，可以写成下面这样。</p><pre class="hljs"><code>$ ls */*.txt
</code></pre><p><strong>（4）可用于文件名。</strong></p><p>Bash 允许文件名使用通配符，即文件名包括通配符字符。这时，引用文件名的时候，需要把文件名放在单引号里面。</p><pre class="hljs"><code>$ touch <span class="hljs-string">'fo*'</span>
$ ls
fo*
</code></pre><p>上面代码创建了一个<code>fo*</code>文件，这时<code>*</code>就是文件名的一部分。</p><h2 id="量词语法">量词语法 <a class="markdownIt-Anchor" href="#量词语法">#</a></h2><p>量词语法用来控制模式匹配的次数。它需要在 Bash 的<code>extglob</code>参数打开的情况下，才能使用。不过，一般是默认打开的，可以用下面的命令查询。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> extglob
extglob        	on
</code></pre><p>量词语法有下面几个。</p><ul><li><code>?(pattern-list)</code>：匹配零个或一个模式。</li><li><code>*(pattern-list)</code>：匹配零个或多个模式。</li><li><code>+(pattern-list)</code>：匹配一个或多个模式。</li><li><code>@(pattern-list)</code>：只匹配一个模式。</li><li><code>!(pattern-list)</code>：匹配零个或一个以上的模式，但不匹配单独一个的模式。</li></ul><pre class="hljs"><code>$ ls abc?(.)txt
abctxt abc.txt
</code></pre><p>上面例子中，<code>?(.)</code>匹配零个或一个点。</p><pre class="hljs"><code>$ ls abc?(def)
abc abcdef
</code></pre><p>上面例子中，<code>?(def)</code>匹配零个或一个<code>def</code>。</p><pre class="hljs"><code>$ ls abc+(.txt|.php)
abc.php abc.txt
</code></pre><p>上面例子中，<code>+(.txt|.php)</code>匹配文件有一个<code>.txt</code>或<code>.php</code>后缀名。</p><pre class="hljs"><code>$ ls abc+(.txt)
abc.txt abc.txt.txt
</code></pre><p>上面例子中，<code>+(.txt)</code>匹配文件有一个或多个<code>.txt</code>后缀名。</p><h2 id="shopt-命令">shopt 命令 <a class="markdownIt-Anchor" href="#shopt-命令">#</a></h2><p><code>shopt</code>命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p><p>它的命令格式如下。</p><pre class="hljs"><code><span class="hljs-comment"># 打开某个参数</span>
$ <span class="hljs-built_in">shopt</span> -s [optionname]

<span class="hljs-comment"># 关闭某个参数</span>
$ <span class="hljs-built_in">shopt</span> -u [optionname]

<span class="hljs-comment"># 查询某个参数关闭还是打开</span>
$ <span class="hljs-built_in">shopt</span> [optionname]
</code></pre><p><strong>（1）dotglob 参数</strong></p><p><code>dotglob</code>参数可以让文件通配符包括隐藏文件（即点开头的文件）。</p><p>正常情况下，通配符扩展不包括隐藏文件。</p><pre class="hljs"><code>$ ls *
abc.txt
</code></pre><p>打开<code>dotglob</code>，就会包括隐藏文件。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> -s dotglob
$ ls *
abc.txt .config
</code></pre><p><strong>（2）nullglob 参数</strong></p><p><code>nullglob</code>参数可以让通配符不匹配任何文件名时，返回空字符。</p><p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p><pre class="hljs"><code>$ rm b*
rm: 无法删除<span class="hljs-string">'b*'</span>: 没有那个文件或目录
</code></pre><p>上面例子中，由于当前目录不包括<code>b</code>开头的文件名，导致<code>b*</code>不会发生文件名扩展，保持原样不变，所以<code>rm</code>命令报错没有<code>b*</code>这个文件。</p><p>打开<code>nullglob</code>参数，就可以让不匹配的通配符返回空字符串。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> -s nullglob
$ rm b*
rm: 缺少操作数
</code></pre><p>上面例子中，由于没有<code>b*</code>匹配的文件名，所以<code>rm b*</code>扩展成了<code>rm</code>，导致报错变成了”缺少操作数“。</p><p><strong>（3）failglob 参数</strong></p><p><code>failglob</code>参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> -s failglob
$ rm b*
bash: 无匹配: b*
</code></pre><p>上面例子中，打开<code>failglob</code>以后，由于<code>b*</code>不匹配任何文件名，Bash 直接报错了，不再让<code>rm</code>命令去处理。</p><p><strong>（4）extglob 参数</strong></p><p><code>extglob</code>参数使得 Bash 支持 ksh 的一些扩展语法。它默认情况下面，应该是打开的。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> extglob
extglob        	on
</code></pre><p>它的主要应用是支持量词语法。如果不希望支持，可以用下面的命令关闭。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> -u extglob
</code></pre><p><strong>（5）nocaseglob 参数</strong></p><p><code>nocaseglob</code>参数可以让通配符扩展不区分大小写。</p><pre class="hljs"><code>$ <span class="hljs-built_in">shopt</span> -s nocaseglob
$ ls /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files (x86)
</code></pre><p>上面例子中，打开<code>nocaseglob</code>以后，<code>program*</code>就不区分大小写了，可以匹配<code>ProgramData</code>等。</p><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener">Think You Understand Wildcards? Think Again</a></li><li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener">Advanced Wildcard Patterns Most People Don’t Know</a></li></ul></article><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="string.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 字符串操作</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="arithmetic.html">Bash 的算术运算 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info is-size-5-desktop"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> Bash 脚本教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 简介</span></a></li><li><a href="grammar.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 的基本语法</span></a></li><li><a href="quotation.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">引号和转义</span></a></li><li><a href="string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串操作</span></a></li><li><a href="expansion.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 的模式扩展</span></a></li><li><a href="arithmetic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 的算术运算</span></a></li><li><a href="variable.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 变量</span></a></li><li><a href="script.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 脚本简介</span></a></li><li><a href="condition.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">条件判断</span></a></li><li><a href="loop.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">循环</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 函数</span></a></li><li><a href="startup.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 启动环境</span></a></li><li><a href="stack.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">目录堆栈</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="readline.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Bash 行操作</span></a></li><li><a href="prompt.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">命令提示符</span></a></li><li><a href="debug.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">脚本除错</span></a></li><li><a href="set.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">set 命令</span></a></li><li><a href="mktemp.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">mktemp 命令</span></a></li><li><a href="trap.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">trap 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/bash-tutorial/master/docs/expansion.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/bash-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/bash-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8"><div id="disqus_thread"></div></div></div></div></section><footer class="footer is-size-5-desktop"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"expansion.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#%E6%B3%A2%E6%B5%AA%E7%BA%BF%E6%89%A9%E5%B1%95">波浪线扩展</a></li>\n<li><a href="#-%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95"><code>?</code> 字符扩展</a></li>\n<li><a href="#-%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95-1"><code>*</code> 字符扩展</a></li>\n<li><a href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%A8%A1%E5%BC%8F">方括号模式</a></li>\n<li><a href="#start-end-%E6%A8%A1%E5%BC%8F">[start-end] 模式</a></li>\n<li><a href="#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95">大括号扩展</a></li>\n<li><a href="#startend-%E6%89%A9%E5%B1%95">{start..end} 扩展</a></li>\n<li><a href="#%E5%8F%98%E9%87%8F%E6%89%A9%E5%B1%95">变量扩展</a></li>\n<li><a href="#%E5%AD%90%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95">子命令扩展</a></li>\n<li><a href="#%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95">算术扩展</a></li>\n<li><a href="#%E5%AD%97%E7%AC%A6%E7%B1%BB">字符类</a></li>\n<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">使用注意点</a></li>\n<li><a href="#%E9%87%8F%E8%AF%8D%E8%AF%AD%E6%B3%95">量词语法</a></li>\n<li><a href="#shopt-%E5%91%BD%E4%BB%A4">shopt 命令</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
const l = window.location;
const url = l.protocol + '//' + l.host + (l.port ? ':' + l.port : '') + l.pathname;
this.page.url = url;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = l.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://wangdoc-bash.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《Bash 的模式扩展》，出自网道（WangDoc.com）的《Bash 脚本教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>